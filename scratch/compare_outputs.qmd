---
format: html
toc: true
---

# Lib
```{r}
library(data.table)
library(quarto)
```

```{r}
#| include: false
"%ni%" <- Negate("%in%")
```

# Load Results
## MAHAJAN 2022 Paper
TODO: comparing against Mahajan results hardcoded for this particular project, maybe remove this codeblock eventually because the rest of the code is otherwise general.\
Also loading `tmp` is a slowdown... smarter way of translating chrposIDs -> rsids?
```{r}
#| cache: true 
loci_configs <- fread("locus.config")
credset_files <- paste0("../data/DIAMANTE2022/fine_mapping/", list.files("../data/DIAMANTE2022/fine_mapping/", pattern="finemap."))
credset_files <- sapply(loci_configs$locus, simplify=F, function(l) grep(l, credset_files, value=T)) # NOTE: one locus can have multiple credset files.

# Read all credset files per locus. List of list of datatables.
mahajan_results <- sapply(loci_configs$locus, simplify=F, function(l)
                   sapply(credset_files[[l]], simplify=F, function(f)
                     fread(f, select=c(      "ID","POST"), # Have to translate to rsids :(
                           col.names=c("chrposID","pip" ))
                   ))

mahajan_results <- lapply(mahajan_results, do.call, what=rbind) # Merge so just one datatable per locus.
mahajan_results <- lapply(mahajan_results, '[', i=order(-pip), j=.SD[1], by=chrposID) # IDs may be duplicated if there were multiple credible set files. Take only max PIP per ID.

# Translate chrposID -> risd
sumstat_ids <- lapply(c("../data/DIAMANTE2022/sumstat/DIAMANTE-EAS.sumstat.txt",
                        "../data/DIAMANTE2022/sumstat/DIAMANTE-EUR.sumstat.txt",
                        "../data/DIAMANTE2022/sumstat/DIAMANTE-SAS.sumstat.txt"),
                      fread, select=c("rsID","chrposID")                        )
sumstat_ids <- do.call(rbind, sumstat_ids)
sumstat_ids <- unique(sumstat_ids, by="rsID")

all_ids_in_credsets <- Reduce(union, lapply(mahajan_results,'[',j=chrposID))
sumstat_ids <- sumstat_ids[ chrposID %in% all_ids_in_credsets ] # Optimization, a bit of pre-filtering
all(all_ids_in_credsets %in% sumstat_ids$chrposID) # Hopefully true!
rm(all_ids_in_credsets)

mahajan_results <- lapply(mahajan_results, function(mr) {
  mr <- merge(x=mr, y=sumstat_ids, by="chrposID")
  mr <- mr[, .(rsID,pip)] # Can toss chrposID now
  setnames(mr, old=c("rsID"), new="rsid")
})
```

## PAINTOR
```{r}
credset_files <- paste0("out/paintor/", list.files("out/paintor/", pattern=".results"))
credset_files <- credset_files[!grepl("LogFile", credset_files)]
paintor_results <- lapply(credset_files, fread, select=c("rsid", "Posterior_Prob"),
                                             col.names=c("rsid",       "pip"     ))
names(paintor_results) <- sub("out/paintor/(.*).results", "\\1", credset_files)
```
## SuSiEx
```{r}
credset_files <- paste0("out/susiex/", list.files("out/susiex/", pattern=".cs")) 
susiex_results <- lapply(credset_files, fread, select=c("SNP", "OVRL_PIP"),
                                            col.names=c("rsid", "pip"  ))
names(susiex_results) <- sub("out/susiex/(.*).cs", "\\1", credset_files)

# Take only max PIP per ID in case of duplicated IDs.
# IDs may be duplicated becuase SuSiEx puts multiple credsets in one .cs file, where which credset a record belongs to is specified by the CS_ID col.
susiex_results <- lapply(susiex_results, '[', i=order(-pip), j=.SD[1], by=rsid) 
```

# Prep Results for JS
```{r}
resultss <- list(Mahajan = mahajan_results,
                 PAINTOR = paintor_results,
                 SuSiEx  =  susiex_results)

# Need to subset
# TODO: Figure out how to subset only as much as is needed to compare the two selected methods, rather than requiring IDs be shared by ALL methods?
common_rsids_per_locus <- sapply(loci_configs$locus, simplify=F, function(l) {
  Reduce(intersect, lapply(resultss, function(results) results[[l]]$rsid))
})

resultss <- mapply(resultss, names(resultss), SIMPLIFY=F, FUN = function(results,method) {
            sapply(loci_configs$locus, simplify=F, function(l) {

              print(paste( sum(results[[l]]$rsid %ni% common_rsids_per_locus[[l]]), "variants omitted from", method, l, "credible set results because they weren't shared." ))
              setorder(rsid, x=results[[l]][rsid %in% common_rsids_per_locus[[l]]])
})})

mahajan_pips <- lapply(resultss$Mahajan, '[', j=pip)
paintor_pips <- lapply(resultss$PAINTOR, '[', j=pip)
susiex_pips  <- lapply(resultss$SuSiEx,  '[', j=pip)

ojs_define(mahajan_pips = mahajan_pips,
           paintor_pips = paintor_pips,
           susiex_pips = susiex_pips)
```

[I update as you change things: ${methodx} & ${methody}: ${locus}]{.aside} \

::: {.column-margin}
Fancy math:
$$\frac{d}{dx}\left( \int_{a}^{x} f(u)\,du\right)=f(x).$$
:::

```{r}
#| echo: false
#| column: margin
plot(rnorm(100),runif(100))
```

# OJS
[Instead of scatterplots, maybe two transparent histograms overlaid ontop of each other, with x-axis being bp?]{.aside}
```{ojs}
//| code-fold: true
viewof methodx = Inputs.radio(["Mahajan2022", "PAINTOR", "SuSiEx"], {label: "Method X", value: "Mahajan2022"})
viewof methody = Inputs.radio(["Mahajan2022", "PAINTOR", "SuSiEx"], {label: "Method Y", value: "SuSiEx"})
viewof locus = Inputs.select(Object.keys(susiex_pips), {label:"Locus"})

method_results = ({
  Mahajan2022: mahajan_pips,
  PAINTOR: paintor_pips,
  SuSiEx: susiex_pips
})

plot_data = [
  method_results[methodx][locus],
  method_results[methody][locus]
]

//Plot.dot(transpose(plot_data), {x: "0", y: "1"}).plot()
Plot.plot({
  grid: true,
  x: {label: methodx.concat(" PIPs")},
  y: {label: methody.concat(" PIPs")},
  marks: [
    Plot.dot(transpose(plot_data), {
      x: (d) => d[0],
      y: (d) => d[1]
    })
  ]
})
```
