---
title: title
toc: true
engine: knitr
format: html
---

# Lib
```{r}
#| output: false
library(data.table)
library(SeqArray)
library(SNPRelate)
```

# Data
```{r}
data_configs <- fread("data.config")
locus_configs <- fread("locus.config")

# TODO: Temporarily just one locus at a time for now. Or just keep it this way but run the script multiple times? __No__, because then would be loading the data multiple times.
  # But what about needlessly holding all those LD mats in mem? Maybe a middleground that only loads the initial data once, and also doesn't require holding the LDs @ once for all loci in mem before even getting to the methods.
  # Or maybe n/ of this matters b/c all the LD has to be written to file a/w so might as well rm() the object right after.
lnm <- locus_configs$locus
lchr <- locus_configs$chr
pos_min <- locus_configs$pos_min
pos_max <- locus_configs$pos_max
```
## Summary stats
```{r}
#| output: false
sumstats <- lapply(1:nrow(data_configs), function(r) {
  sumstat          <-       data_configs[r, fread(filepath, select=c(chr_col, pos_col, rsid_col, other_allele_col, effect_allele_col, eaf_col, b_col, se_col, z_col, p_col))]
  unspecified_cols <- is.na(data_configs[r,                        .(chr_col, pos_col, rsid_col, other_allele_col, effect_allele_col, eaf_col, b_col, se_col, z_col, p_col)])
  setnames(sumstat,                                               c("chr",   "pos",   "rsid",   "a0",             "a1",              "eaf",   "b",   "se",   "z",   "p"   )[!unspecified_cols])
  sumstat[, `:=`(a0=toupper(a0), a1=toupper(a1))]
  if(data_configs[r, is.na(z_col) & !is.na(b_col) & !is.na(se_col)]) sumstat[, z := b/se]
  # TODO: s/t s/t complete.cases or w/e to deal w/ remaining NAs, and be verbose about what is removed.
})
names(sumstats) <- paste0("sumstat", 1:length(sumstats))
```
## Reference panel
```{r}
#| output: false
# TODO: Hardcoded to use 1kG for now. Possibly support TOPMed later.
ref <- seqOpen("../data/ref/1kg/gds_format/1KG_ALL.autosomes.phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.gds", readonly=F, allow.duplicate=T)

# TODO: Move to a pre-process script and perform on a COPY of the data and store s/where. Annoying, but the "data/" dir should really remain untouched. Should be able to look in there and take md5sums and be confident e/t in there is raw.
sample_info <- fread("../data/ref/1kg/sample_info/integrated_call_samples_v3.20130502.ALL.panel")
identical(seqGetData(ref,"sample.id"), sample_info$sample)
seqAddValue(ref, "sample.annotation/ancestry", sample_info$super_pop, replace=T)
seqAddValue(ref, "sample.annotation/gender", sample_info$gender, replace=T)
```

# Subset
```{r}
#| output: false
# TODO: tapply could be more readable/elegant than this "samples_of_each_ancestry" stuff?
  # s/t s/t tapply(seqGetData(ref,"sample.id"), INDEX=factor(seqGetData(ref, "sample.annotation/ancestry"))

# TODO: mJAM can handle NAs! So, take advantage of that and don't just subset for all methods...
  # I think this is actually pretty easy, just save the subset by common_rsids for later,
  # And calc LD for the unique(union(lapply(sumstats, function(s) s$rsid

# TODO: Only 1 locus at a time for now. How to write elegantly for multiple? (Probably) Not nested lapply's and "sumstatss".
  # outer lapply by locus kinda bulky and loading all that into memory hurts.
  # Perhaps, wrap this all into a function, to run once per locus, and then loop over that.

# Filter by valid/desired variants in sumstats
sumstats <- lapply(sumstats, function(ss) ss[ chr ==  lchr  &
                                              pos > pos_min &
                                              pos < pos_max &
                                              eaf >    0    &
                                              eaf <    1      ])

# Filter ref by variants common to all sumstats files
rsids <- lapply(sumstats, function(ss) ss$rsid)
common_rsids <- Reduce(intersect, rsids)
seqSetFilterAnnotID(ref, common_rsids)

# Filter ref by variants where MAF > 0 for ~every~ ancestry
ancestries <- unique(data_configs$ancestry)
names(ancestries) <- ancestries # TODO: ocd, technically not necessary, only helps readability in dev but not final product, bothering me a little

samples_of_each_ancestry <- lapply(ancestries, function(a) {
  seqResetFilter(ref, variant=F)
  samples_of_this_ancestry <- seqGetData(ref,"sample.annotation/ancestry") == a
  seqSetFilter(ref, sample.sel = samples_of_this_ancestry)
  seqGetData(ref, "sample.id")
})

ancestry_AFs <- lapply(samples_of_each_ancestry, function(samples_of_an_ancestry) {
  seqResetFilter(ref, variant=F)
  seqSetFilter(ref, sample.id = samples_of_an_ancestry)
  seqAlleleFreq(ref, ref.allele=1) # TODO: Not ~quite~ correct b/c only the first allele of multi-allelic variants get considered
})
ancestry_AFs <- as.data.table(ancestry_AFs) # variant rows, ancestry cols

valid_vs_in_ref <- apply(ancestry_AFs, 1, function(v_afs) all(v_afs>0 & v_afs<1))
seqSetFilter(ref, variant.sel=valid_vs_in_ref, action="intersect")

# Filter by variants common to all sumstats AND ref
common_rsids <- intersect(common_rsids, seqGetData(ref,"annotation/id"))
sumstats <- lapply(sumstats, function(ss) ss[rsid %in% common_rsids])
sumstats <- lapply(sumstats, function(ss) ss[      order(rsid)     ]) # Put all sumstats same order, by rs id.
```

# LD
```{r}
# TODO: calc_ld.R was in fact inelegant, bad. Instead, have the fn take a gds pointer assuming the filters you want are already applied.
  # Also my function is bad b/c it has the side-effect of closing the file.
  # Just embrace the GDS fully, expect the user to use a GDS file as input, and rewrite the fn to expect a pointer to a GDS file.
# TODO: Alternatively: calc_ld <- function <"FUN = stuff", but also w/ locus>; Vectorize(calc_ld, vectorize.args=c("sumstat","samples")); Vectorize(calc_ldv, vectorize.args=c("locus"). Also SIMPLIFY=F. May be more readable?
  # B/c then can just do calc_ld(sumstats, samples_of_each_ancestry, loci)
lds <- mapply(samples_of_each_ancestry, sumstats, SIMPLIFY=F,
FUN = function(samples_of_an_ancestry,  sumstat) {
  seqSetFilter(ref, sample.id = samples_of_an_ancestry)
  tmp_filename <- "/tmp/snpgds_format_file.gds"
  seqGDS2SNP(ref, tmp_filename, compress.geno="", compress.annotation="")
  tmp <- snpgdsOpen(tmp_filename, readonly=F)
  snpgdsAlleleSwitch(tmp, toupper(sumstat$a0))
  ld <- snpgdsLDMat(tmp, slide=0, method="corr", num.thread=parallel::detectCores())$LD

  snpgdsClose(tmp)
  unlink(tmp_filename)

  # Sort LD matrix to match order of rs IDs in sumstats
  snv_order <- match(seqGetData(ref, "annotation/id"), sumstat$rsid)
  ld[snv_order,snv_order]
})

mapply(lds, ancestries, FUN = function(ld, a) fwrite(ld, paste0("in/ld/",a,".ld"), sep=' '))
```

# Run Fine-Mapping Methods
## SuSiEx
### Prep Input
SuSiEx is a command-line python program. It expects the following:\
A summary stats file, as follows:\ 
TODO: make nice table\
The Î² column _must_ be named "BETA" or "OR", but besides that they may be named arbitrarily.
```{r}
mapply(sumstats, ancestries, FUN=function(ss,anc) {
  ss <- ss[, .(chr,pos,rsid,a0,a1,b,se,p)]
  setnames(ss, old="b", new="BETA", skip_absent=T)
  fwrite(ss, paste0("in/susiex/sumstat-",anc,".txt"), sep=' ')
})
```

```{r}
# TODO: PLINK stuff :(
  # NOTE TO SELF: see daily note 230605. Letting SuSiEx recompute its own LD for now just to get things working.
```

### Run SuSiEx
```{r}
system(paste("python3 ../third_party/SuSiEx/SuSiEx.py",
             "--sst_file", paste(collapse=',', paste0("in/susiex/sumstat-",ancestries,".txt")),
             "--n_gwas",   paste(collapse=',', data_configs$n),
             "--ld_file",  paste(collapse=',', paste0("in/ld/",ancestries,"-susiex" )),
             "--ref_file ../data/ref/1kg/plink_format/eas/g1000_eas,../data/ref/1kg/plink_format/eur/g1000_eur,../data/ref/1kg/plink_format/sas/g1000_sas", # TODO:
             "--plink plink", # TODO:
             "--out_dir out/susiex/",
             "--out_name", lnm, # TODO:
             "--chr ", lchr,
             "--bp ", paste(sep=',', pos_min,pos_max),
             "--chr_col", paste(collapse=',', rep(1,nrow(data_configs))),
             "--bp_col",  paste(collapse=',', rep(2,nrow(data_configs))),
             "--snp_col", paste(collapse=',', rep(3,nrow(data_configs))),
             "--a1_col",  paste(collapse=',', rep(4,nrow(data_configs))),
             "--a2_col",  paste(collapse=',', rep(5,nrow(data_configs))),
             "--eff_col", paste(collapse=',', rep(6,nrow(data_configs))),
             "--se_col",  paste(collapse=',', rep(7,nrow(data_configs))),
             "--pval_col",paste(collapse=',', rep(8,nrow(data_configs))),
             "--maf 0.005", 
             "--mult-step True",
             "--keep-ambig True",
             "--full_out True"
             # defaults: --max_iter=100, --pval_thresh=1e-5, --tol=1e-4, --n_sig=5, --level=95%, --min_purity=0.5
))
```

## PAINTOR
### Prep Input
TODO: desc
```{r}
# input.files
writeLines(locus_configs$locus, "in/paintor/input.files")

# LD
# Unfortunately PAINTOR insists on having all its input files in a single dir, so that means either cluttering in/ld/ or making copies of the LD....
# TODO: write this earlier so don't have to hang onto in mem? Although it is just one per anc in the ref.
mapply(lds, ancestries, FUN = function(ld, a)
  fwrite(ld, paste0("in/paintor/",locus_configs$locus,".ld_",a), sep=' ', col.names=F)
) 

# Locus file
# TODO: naming business could be cleaner probably
sapply(locus_configs$locus, function(l) {
  lf <- setDT(lapply(sumstats, function(ss) ss$z))
  setnames(lf, paste0("z_",names(lf)))
  lf <- cbind(sumstats[[1]][rsid %in% common_rsids, .(rsid,chr,pos)], lf) # Can add more metadata than just rsid,chr,pos if you want
  fwrite(lf, paste0("in/paintor/",l), sep=' ')
})

# Annotation file
# TODO: dummy all-0s file for now
writeLines(c("dummy_annot", rep(0,nrow(sumstats[[1]]))), paste0("in/paintor/",locus_configs$locus,".annotations"))
```

### Run PAINTOR
```{r}
system(paste("../third_party/PAINTOR_V3.0/PAINTOR",
             "-input in/paintor/input.files",
             "-in in/paintor/",
             "-out out/paintor/",
             "-Zhead",  paste(collapse=',', paste0("z_",names(sumstats))),
             "-LDname", paste(collapse=',', paste0("ld_",data_configs$ancestry)),
             "-annotations dummy_annot",
             "-enumerate 1"
))
```
