---
title: title
toc: true
engine: knitr
format: html
---

# Lib
```{r}
#| output: false
library(data.table)
library(SeqArray)
library(SNPRelate)
```

# Data
```{r}
data_configs <- fread("data.config")
data_configs <- split(data_configs, rownames(data_configs)) # Turns into list of the rows
#data_configs <- apply(data_configs, 1, as.list, simplify=F) # ^ but uglier
# TODO: Handle multiple sumstats having the same ancestry


locus_configs <- fread("locus.config")
# TODO: Temporarily just one locus at a time for now. Or just keep it this way but run the script multiple times? __No__, because then would be loading the data multiple times.
  # BUT what about needlessly holding all those LD mats, taking up memory? Come up w/ an in-between solution that only loads the initial data once, but doesn't require holding the LDs for all the variants in mem @ once before even getting to the methods.
#locus_configs <- split(locus_configs, rownames(locus_configs))
lnm <- locus_configs$locus
lchr <- locus_configs$chr
pos_min <- locus_configs$pos_min
pos_max <- locus_configs$pos_max
```
## Summary stats
```{r}
#| output: false
# TODO: only select the cols actually given. Some may be left blank.
sumstats <- lapply(data_configs, function(d) {
  sumstat <- fread(d$filepath, header=T, select=c(d$chr_col, d$pos_col, d$rsid_col, d$other_allele_col, d$effect_allele_col, d$eaf_col, d$b_col, d$se_col, d$p_col))
  setnames(sumstat,                             c( "chr",     "pos",     "rsid",     "a0",                "a1",               "eaf",     "b",     "se",     "p"   ))
})
```
## Reference panel
```{r}
#| output: false
# TODO: Hardcoded to use 1kG for now. Possibly support TOPMed later.
ref <- seqOpen("../data/ref/1kg/gds_format/1KG_ALL.autosomes.phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.gds", readonly=F, allow.duplicate=T)

# TODO: Move to a pre-process script and perform on a COPY of the data and store s/where. Annoying, but the "data/" dir should really remain untouched. Should be able to look in there and take md5sums and be confident e/t in there is raw.
sample_info <- fread("../data/ref/1kg/sample_info/integrated_call_samples_v3.20130502.ALL.panel")
identical(seqGetData(ref,"sample.id"), sample_info$sample)
seqAddValue(ref, "sample.annotation/ancestry", sample_info$super_pop, replace=T)
seqAddValue(ref, "sample.annotation/gender", sample_info$gender, replace=T)
```

# Subset
```{r}
#| output: false
# TODO: tapply could be more readable/elegant than this "samples_of_each_ancestry" stuff?
  # s/t s/t tapply(..., INDEX=as.factor(seqGetData(ref, "sample.annotation/ancestry"))?

# TODO: mJAM can handle NAs! So, take advantage of that and don't just subset for all methods...

# TODO: Only 1 locus at a time for now. How to write elegantly for multiple? (Probably) Not nested lapply's and "sumstatss".
  # outer lapply by locus kinda bulky and loading all that into memory hurts.
  # Perhaps, wrap this all into a function, to run once per locus, and then loop over that.

# Filter by valid/desired variants in sumstats
sumstats <- lapply(sumstats, function(x) x[ chr ==  lchr  &
                                            pos > pos_min &
                                            pos < pos_max &
                                            eaf >    0    &
                                            eaf <    1      ])
#TODO: move the anc-specific af stuff and subset by THAT valid stuff here,
  # And then do all the common snvs stuff subsetting at the end?

# Filter ref by variants common to all sumstats files
snvs <- lapply(sumstats, function(x) x$rsid)
common_snvs <- Reduce(intersect, snvs)
seqSetFilterAnnotID(ref, common_snvs)

# Filter ref by variants where MAF > 0 for ~every~ ancestry
ancestries <- unique(sapply(data_configs, function(d) d$ancestry))

samples_of_each_ancestry <- lapply(ancestries, USE.NAMES=T, function(a) {
  seqResetFilter(ref, variant=F)
  samples_of_this_ancestry <- seqGetData(ref,"sample.annotation/ancestry") == a
  seqSetFilter(ref, sample.sel = samples_of_this_ancestry)
  seqGetData(ref, "sample.id")
})
seqResetFilter(ref, variant=F)
names(samples_of_each_ancestry) <- ancestries

ancestry_AFs <- lapply(samples_of_each_ancestry, function(samples_of_an_ancestry) {
  seqResetFilter(ref, variant=F)
  seqSetFilter(ref, sample.id = samples_of_an_ancestry)
  seqAlleleFreq(ref, ref.allele=1) # TODO: Not ~quite~ correct b/c only the first allele of multi-allelic variants get considered
})
seqResetFilter(ref, variant=F)
ancestry_AFs <- Reduce(cbind, ancestry_AFs) # Lists of AFs -> matrix with snv rows, ancestry cols

valid_snvs_in_ref <- apply(ancestry_AFs, 1, function(snv_afs) all(snv_afs>0 & snv_afs<1))
seqSetFilter(ref, variant.sel=valid_snvs_in_ref, action="intersect")

# Filter by variants common to all sumstats AND ref
common_snvs <- intersect(common_snvs, seqGetData(ref,"annotation/id"))
sumstats <- lapply(sumstats, function(x) x[rsid %in% common_snvs])
sumstats <- lapply(sumstats, function(x) x[     order(rsid)     ]) # Put all sumstats same order, by rs id.
```

# LD
```{r}
# TODO: calc_ld.R was in fact inelegant, bad. Instead, have the fn take a gds pointer assuming the filters you want are already applied.
  # Also my function is bad b/c it has the side-effect of closing the file.
  # Just embrace the GDS fully, expect the user to use a GDS file as input, and rewrite the fn to expect a pointer to a GDS file.
# TODO: Alternatively: calc_ld <- function <"FUN = stuff", but also w/ locus>; Vectorize(calc_ld, vectorize.args=c("sumstat","samples")); Vectorize(calc_ldv, vectorize.args=c("locus"). Also SIMPLIFY=F. May be more readable?
  # B/c then can just do calc_ld(sumstats, samples_of_each_ancestry, loci)
lds <- mapply(samples_of_each_ancestry, sumstats, SIMPLIFY=F,
FUN = function(samples_of_an_ancestry,  sumstat) {
  seqSetFilter(ref, sample.id = samples_of_an_ancestry)
  tmp_filename <- "/tmp/snpgds_format_file.gds"
  seqGDS2SNP(ref, tmp_filename, compress.geno="", compress.annotation="")
  tmp <- snpgdsOpen(tmp_filename, readonly=F)
  snpgdsAlleleSwitch(tmp, toupper(sumstat$a0))
  ld <- snpgdsLDMat(tmp, slide=0, method="corr", num.thread=parallel::detectCores())$LD

  snpgdsClose(tmp)
  unlink(tmp_filename)

  # Sort LD matrix to match order of rs IDs in sumstats
  snv_order <- match(sumstat$rsid, seqGetData(ref, "annotation/id"))
  ld[snv_order,snv_order]
})

mapply(lds, ancestries, FUN = function(ld, a) fwrite(ld, paste0("in/ld/",a,".ld"), sep=' '))
```


# Run Methods
## SuSiEx
### Prep Input
SuSiEx is a command-line python program. It expects the following: \
A summary stats file, with at least chromosome, position, ID, effect and alternate allele, <TODO> \

The Î² column must be named "BETA" (a bit annoying).
```{r}
mapply(sumstats, ancestries, FUN=function(ss,anc) {
  setnames(ss, old="b", new="BETA", skip_absent=T)
  fwrite(ss, paste0("in/susiex/sumstat-",anc,".txt"), sep=' ')
  setnames(ss, old="BETA", new="b", skip_absent=T)
})
```

```{r}
# TODO: PLINK stuff :(
  # NOTE TO SELF: see daily note 230605. Letting SuSiEx recompute its own LD for now just to get things working.
```

### Run SuSiEx
```{r}
paste(collapse=',', paste0(sapply(data_configs, function(d) d$n)))
paste(collapse=',', paste0(
system(paste0("python3 ../third_party/SuSiEx/SuSiEx.py \\",
              "--sst_file=", paste(collapse=',', paste0("in/susiex/sumstat-",ancestries,".txt")),
              "--n_gwas=",   paste(collapse=',', sapply(data_configs, function(d) d$n))
```
